在C++中，动态存储期（Dynamic Storage Duration）是指对象的生命周期可以在运行时动态控制的存储期。这种存储期的对象通常通过`new`操作符创建，并通过`delete`操作符销毁。

除了动态存储期，C++还有以下几种存储期：

1. 静态存储期（Static Storage Duration）：对象在程序的整个生命周期内都存在。例如使用static声明全局变量和静态变量。
2. 线程存储期（Thread Storage Duration）：对象在其所在线程的生命周期内存在。例如使用`thread_local`关键字声明的变量。
3. 自动存储期（Automatic Storage Duration）：对象在其定义的代码块（例如函数）执行期间存在。例如函数内的没有使用static声明的局部变量。

**C++中的枚举类型**

>枚举类型（enum）的内存布局取决于其底层类型。默认情况下，底层类型通常是`int`，但你也可以在声明枚举时指定其他类型。每个枚举值都会被赋予一个整数，这些整数在内存中是连续存储的。例如，如果你有一个枚举类型如下：
>
>```c++
>enum Color { Red, Green, Blue };
>```
>
>那么`Red`、`Green`和`Blue`将被赋予值0、1和2。如果你创建了一个`Color`类型的变量，那么这个变量在内存中将占据和底层类型相同的空间。在默认情况下，这将是一个`int`的大小。
>
>需要注意的是，枚举类型的值在内存中并不是按照枚举类型的声明顺序存储的，而是按照枚举变量的声明和初始化顺序存储的。例如，如果你首先声明并初始化了一个`Blue`的变量，然后声明并初始化了一个`Red`的变量，那么在内存中，`Blue`的变量将位于`Red`的变量之前。
>
>**一个枚举类声明的变量只能被赋予该枚举类中定义的值**

**分配的动态对象如果不能够释放就会造成内存泄漏，即程序不再需要的内存没有被释放**

> 在实际使用中如果编写的是用户模式的代码，现代操作系统会在程序退出的时候清理资源。但是如果编写的是内核代码，操作系统将不会清理资源，只有在系统重启的时候回收资源

**c++中的标准异常类**

>c++中的标准异常类都是继承std：：exception的子类，可划分为三组：逻辑错误、运行时错误、和语言支持错误
>
>- logic_error
>  - domain_error 报告了与有效输入范围有关的错误
>  - invalid_argument 报告意外的参数错误
>  - length_error 报告某些操作违反了最大尺寸约束
>- runtime_error
>  - system_error报告操作系统遇到的错误
>  - overflow_error和underflow_error 分别报告算术上溢和下溢出

**调用栈和异常**

调用栈是一个运行时结构，存储了当前正在运行的函数信息。

**移动语义**

使用std::move可以将左值转化为右值，这样做的主要目的是为了实现"移动语义"，即允许资源的转移而不是复制，这可以提高程序的效率。

>左值（Lvalue）和右值（Rvalue）是用来描述表达式的属性的术语。
>
>1. 左值：它指的是一个可以在等号左边出现的表达式，也就是说，它代表的是一个对象的身份（内存中的位置）。左值有持久的存储期，你可以取其地址。例如，一个变量就是一个左值。
>2. 右值：它指的是一个可以在等号右边出现的表达式，也就是说，它代表的是一个对象的值而非身份。右值是临时的，它们要么是字面量（如`5`或`"hello"`），要么是在表达式求值过程中创建的临时对象。

**继承**

- 可以将派生类当做基类引用类型来使用
- 派生类从基类中继承非私有成员，类可以像使用普通成员一样使用继承的成员，与基于组合的多态相比，其很容易产生脆弱的，难以理解的代码
- 私有成员不能够被派生类继承

**虚方法**

- 使用virtual关键词相当于对函数进行重载，基类的实现只能在基类的实例才会使用
- 纯虚函数是派生类必须要自己实现的方法
- 虚函数在运行时也会产生运行时的开销，原因是虚函数的实现通常依赖虚函数表和虚函数指针
